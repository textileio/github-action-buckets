/**
 * @packageDocumentation
 * @module @textile/threads-client
 */
import { grpc } from '@improbable-eng/grpc-web';
import { Identity } from '@textile/threads-core';
import { ThreadID } from '@textile/threads-id';
import { Context } from '@textile/context';
import { QueryJSON, Instance, InstanceList, Filter, Query, Where, WriteTransaction, ReadTransaction } from './models';
export { ThreadID };
export { Instance, QueryJSON };
export { Query, Where };
/**
 * Client is a web-gRPC wrapper client for communicating with a webgRPC-enabled Textile server.
 * This client library can be used to interact with a local or remote Textile gRPC-service
 *  It is a wrapper around Textile's 'DB' API, which is defined here: https://github.com/textileio/go-threads/blob/master/api/pb/api.proto.
 */
export declare class Client {
    context: Context;
    serviceHost: string;
    rpcOptions: grpc.RpcOptions;
    /**
     * Creates a new gRPC client instance for accessing the Textile Threads API.
     * @param context The context to use for interacting with the APIs. Can be modified later.
     */
    constructor(context?: Context);
    /**
     * Obtain a token for interacting with the remote network API.
     * @param identity The generic identity to use for signing and validation.
     * @param ctx Context object containing web-gRPC headers and settings.
     * @note If an identity is not provided, a random PKI identity is used. This might not be what you want!
     * It is not easy/possible to migrate identities after the fact. Please supply an identity argument if
     * you wish to persist/retrieve user data later.
     */
    getToken(identity?: Identity, ctx?: Context): Promise<string>;
    /**
     * newDB creates a new store on the remote node.
     * @param dbID the ID of the database
     * @param ctx Context object containing web-gRPC headers and settings.
     */
    newDB(dbID?: ThreadID, ctx?: Context): Promise<ThreadID>;
    /**
     * newCollection registers a new model schema under the given name on the remote node.
     * The schema must be a valid json-schema.org schema, and can be a JSON string or Javascript object.
     * @param dbID the ID of the database
     * @param name The human-readable name for the model.
     * @param schema The actual json-schema.org compatible schema object.
     */
    newCollection(dbID: ThreadID, name: string, schema: any): Promise<void>;
    /**
     * newDBFromAddr initializes the client with the given store, connecting to the given
     * thread address (database). It should be called before any operation on the store, and is an
     * alternative to start, which creates a local store. newDBFromAddr should also include the
     * read and follow keys, which should be Buffer, Uint8Array or base58-encoded strings.
     * See `getDBInfo` for a possible source of the address and keys.
     * @param address The address for the thread with which to connect.
     * Should be of the form /ip4/<url/ip-address>/tcp/<port>/p2p/<peer-id>/thread/<thread-id>
     * @param key The set of keys to use to connect to the database
     * @param collections An array of Name and JSON Schemas for collections in the DB.
     */
    newDBFromAddr(address: string, key: string | Uint8Array, collections: Array<{
        name: string;
        schema: any;
    }>): Promise<unknown>;
    /**
     * getDBInfo returns invite 'links' unseful for inviting other peers to join a given store/thread.
     * @param dbID the ID of the database
     */
    getDBInfo(dbID: ThreadID): Promise<{
        address: string;
        key: string;
    }[]>;
    /**
     * Creates a new model instance in the given store.
     * @param dbID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     * @param values An array of model instances as JSON/JS objects.
     */
    create(dbID: ThreadID, collectionName: string, values: any[]): Promise<string[]>;
    /**
     * Saves changes to an existing model instance in the given store.
     * @param dbID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     * @param values An array of model instances as JSON/JS objects. Each model instance must have a valid existing `ID` property.
     */
    save(dbID: ThreadID, collectionName: string, values: any[]): Promise<void>;
    /**
     * Deletes an existing model instance from the given store.
     * @param dbID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     * @param IDs An array of instance ids to delete.
     */
    delete(dbID: ThreadID, collectionName: string, IDs: string[]): Promise<void>;
    /**
     * has checks whether a given instance exists in the given store.
     * @param dbID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     * @param IDs An array of instance ids to check for.
     */
    has(dbID: ThreadID, collectionName: string, IDs: string[]): Promise<boolean>;
    /**
     * find queries the store for entities matching the given query parameters.
     * @param dbID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     * @param query The object that describes the query. User Query class or primitive QueryJSON type.
     */
    find<T = any>(dbID: ThreadID, collectionName: string, query: QueryJSON): Promise<InstanceList<T>>;
    /**
     * findByID queries the store for the id of an instance.
     * @param dbID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     * @param ID The id of the instance to search for.
     */
    findByID<T = any>(dbID: ThreadID, collectionName: string, ID: string): Promise<Instance<T>>;
    /**
     * readTransaction creates a new read-only transaction object. See ReadTransaction for details.
     * @param dbID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     */
    readTransaction(dbID: ThreadID, collectionName: string): ReadTransaction;
    /**
     * writeTransaction creates a new writeable transaction object. See WriteTransaction for details.
     * @param dbID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     */
    writeTransaction(dbID: ThreadID, collectionName: string): WriteTransaction;
    /**
     * listen opens a long-lived connection with a remote node, running the given callback on each new update to the given instance.
     * The return value is a `close` function, which cleanly closes the connection with the remote node.
     * @param dbID the ID of the database
     * @param filters contains an array of Filters
     * @param callback The callback to call on each update to the given instance.
     */
    listen<T = any>(dbID: ThreadID, filters: Filter[], callback: (reply?: Instance<T>, err?: Error) => void): () => void;
    private unary;
}
export default Client;
