"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = exports.Where = exports.Query = exports.ThreadID = void 0;
/**
 * @packageDocumentation
 * @module @textile/threads-client
 */
/* eslint-disable @typescript-eslint/no-non-null-assertion */
const grpc_web_1 = require("@improbable-eng/grpc-web");
const api_pb_service_1 = require("@textile/threads-client-grpc/api_pb_service");
const pb = __importStar(require("@textile/threads-client-grpc/api_pb"));
const next_tick_1 = __importDefault(require("next-tick"));
const threads_core_1 = require("@textile/threads-core");
const multiaddr_1 = require("@textile/multiaddr");
const threads_id_1 = require("@textile/threads-id");
Object.defineProperty(exports, "ThreadID", { enumerable: true, get: function () { return threads_id_1.ThreadID; } });
const context_1 = require("@textile/context");
const bs58_1 = require("bs58");
const models_1 = require("./models");
Object.defineProperty(exports, "Query", { enumerable: true, get: function () { return models_1.Query; } });
Object.defineProperty(exports, "Where", { enumerable: true, get: function () { return models_1.Where; } });
/**
 * Client is a web-gRPC wrapper client for communicating with a webgRPC-enabled Textile server.
 * This client library can be used to interact with a local or remote Textile gRPC-service
 *  It is a wrapper around Textile's 'DB' API, which is defined here: https://github.com/textileio/go-threads/blob/master/api/pb/api.proto.
 */
class Client {
    /**
     * Creates a new gRPC client instance for accessing the Textile Threads API.
     * @param context The context to use for interacting with the APIs. Can be modified later.
     */
    constructor(context = new context_1.Context('http://127.0.0.1:6007')) {
        this.context = context;
        this.serviceHost = context.host;
        this.rpcOptions = {
            transport: context.transport,
            debug: context.debug,
        };
        // If we have a default here, use it. Otherwise, rely on specific calls
        this.rpcOptions.transport && grpc_web_1.grpc.setDefaultTransport(this.rpcOptions.transport);
    }
    /**
     * Obtain a token for interacting with the remote network API.
     * @param identity The generic identity to use for signing and validation.
     * @param ctx Context object containing web-gRPC headers and settings.
     * @note If an identity is not provided, a random PKI identity is used. This might not be what you want!
     * It is not easy/possible to migrate identities after the fact. Please supply an identity argument if
     * you wish to persist/retrieve user data later.
     */
    getToken(identity, ctx) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = grpc_web_1.grpc.client(api_pb_service_1.API.GetToken, {
                host: this.serviceHost,
                transport: this.rpcOptions.transport,
                debug: this.rpcOptions.debug,
            });
            const ident = identity !== null && identity !== void 0 ? identity : (yield threads_core_1.Libp2pCryptoIdentity.fromRandom());
            return new Promise((resolve, reject) => {
                let token;
                client.onMessage((message) => __awaiter(this, void 0, void 0, function* () {
                    if (message.hasChallenge()) {
                        const challenge = message.getChallenge();
                        let sig = Buffer.from('');
                        try {
                            sig = yield ident.sign(Buffer.from(challenge));
                        }
                        catch (err) {
                            reject(err);
                        }
                        const req = new pb.GetTokenRequest();
                        req.setSignature(sig);
                        client.send(req);
                    }
                    else if (message.hasToken()) {
                        token = message.getToken();
                    }
                }));
                client.onEnd((code) => {
                    client.close();
                    if (code === grpc_web_1.grpc.Code.OK) {
                        this.context.withToken(token);
                        resolve(token);
                    }
                    else {
                        reject(new Error(code.toString()));
                    }
                });
                const req = new pb.GetTokenRequest();
                req.setKey(ident.public.toString());
                const metadata = JSON.parse(JSON.stringify(this.context.withContext(ctx)));
                client.start(metadata);
                client.send(req);
                // client.finishSend()
            });
        });
    }
    /**
     * newDB creates a new store on the remote node.
     * @param dbID the ID of the database
     * @param ctx Context object containing web-gRPC headers and settings.
     */
    newDB(dbID, ctx) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = dbID !== null && dbID !== void 0 ? dbID : threads_id_1.ThreadID.fromRandom();
            const req = new pb.NewDBRequest();
            req.setDbid(id.toBytes());
            yield this.unary(api_pb_service_1.API.NewDB, req);
            this.context.withThread && this.context.withThread(id);
            return id;
        });
    }
    /**
     * newCollection registers a new model schema under the given name on the remote node.
     * The schema must be a valid json-schema.org schema, and can be a JSON string or Javascript object.
     * @param dbID the ID of the database
     * @param name The human-readable name for the model.
     * @param schema The actual json-schema.org compatible schema object.
     */
    newCollection(dbID, name, schema) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = new pb.NewCollectionRequest();
            const config = new pb.CollectionConfig();
            config.setName(name);
            config.setSchema(Buffer.from(JSON.stringify(schema)));
            req.setDbid(dbID.toBytes());
            req.setConfig(config);
            yield this.unary(api_pb_service_1.API.NewCollection, req);
            return;
        });
    }
    /**
     * newDBFromAddr initializes the client with the given store, connecting to the given
     * thread address (database). It should be called before any operation on the store, and is an
     * alternative to start, which creates a local store. newDBFromAddr should also include the
     * read and follow keys, which should be Buffer, Uint8Array or base58-encoded strings.
     * See `getDBInfo` for a possible source of the address and keys.
     * @param address The address for the thread with which to connect.
     * Should be of the form /ip4/<url/ip-address>/tcp/<port>/p2p/<peer-id>/thread/<thread-id>
     * @param key The set of keys to use to connect to the database
     * @param collections An array of Name and JSON Schemas for collections in the DB.
     */
    newDBFromAddr(address, key, collections) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = new pb.NewDBFromAddrRequest();
            const addr = new multiaddr_1.Multiaddr(address).buffer;
            req.setAddr(addr);
            req.setKey(typeof key === 'string' ? bs58_1.decode(key) : key);
            req.setCollectionsList(collections.map((c) => {
                const config = new pb.CollectionConfig();
                config.setName(c.name);
                config.setSchema(JSON.stringify(c.schema));
                return config;
            }));
            return yield this.unary(api_pb_service_1.API.NewDBFromAddr, req);
        });
    }
    /**
     * getDBInfo returns invite 'links' unseful for inviting other peers to join a given store/thread.
     * @param dbID the ID of the database
     */
    getDBInfo(dbID) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = new pb.GetDBInfoRequest();
            req.setDbid(dbID.toBytes());
            const res = (yield this.unary(api_pb_service_1.API.GetDBInfo, req));
            const invites = [];
            for (const addr of res.addrsList) {
                const dk = Buffer.from(res.key, 'base64');
                const a = typeof addr === 'string' ? Buffer.from(addr, 'base64') : Buffer.from(addr);
                const address = new multiaddr_1.Multiaddr(a).toString();
                invites.push({
                    address,
                    key: bs58_1.encode(dk),
                });
            }
            return invites;
        });
    }
    /**
     * Creates a new model instance in the given store.
     * @param dbID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     * @param values An array of model instances as JSON/JS objects.
     */
    create(dbID, collectionName, values) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = new pb.CreateRequest();
            req.setDbid(dbID.toBytes());
            req.setCollectionname(collectionName);
            const list = [];
            values.forEach((v) => {
                list.push(Buffer.from(JSON.stringify(v)));
            });
            req.setInstancesList(list);
            const res = (yield this.unary(api_pb_service_1.API.Create, req));
            return res.instanceidsList;
        });
    }
    /**
     * Saves changes to an existing model instance in the given store.
     * @param dbID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     * @param values An array of model instances as JSON/JS objects. Each model instance must have a valid existing `ID` property.
     */
    save(dbID, collectionName, values) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = new pb.SaveRequest();
            req.setDbid(dbID.toBytes());
            req.setCollectionname(collectionName);
            const list = [];
            values.forEach((v) => {
                if (!v.hasOwnProperty('ID')) {
                    v['ID'] = ''; // The server will add an ID if empty.
                }
                list.push(Buffer.from(JSON.stringify(v)));
            });
            req.setInstancesList(list);
            yield this.unary(api_pb_service_1.API.Save, req);
            return;
        });
    }
    /**
     * Deletes an existing model instance from the given store.
     * @param dbID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     * @param IDs An array of instance ids to delete.
     */
    delete(dbID, collectionName, IDs) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = new pb.DeleteRequest();
            req.setDbid(dbID.toBytes());
            req.setCollectionname(collectionName);
            req.setInstanceidsList(IDs);
            yield this.unary(api_pb_service_1.API.Delete, req);
            return;
        });
    }
    /**
     * has checks whether a given instance exists in the given store.
     * @param dbID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     * @param IDs An array of instance ids to check for.
     */
    has(dbID, collectionName, IDs) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = new pb.HasRequest();
            req.setDbid(dbID.toBytes());
            req.setCollectionname(collectionName);
            req.setInstanceidsList(IDs);
            const res = (yield this.unary(api_pb_service_1.API.Has, req));
            return res.exists;
        });
    }
    /**
     * find queries the store for entities matching the given query parameters.
     * @param dbID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     * @param query The object that describes the query. User Query class or primitive QueryJSON type.
     */
    find(dbID, collectionName, query) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = new pb.FindRequest();
            req.setDbid(dbID.toBytes());
            req.setCollectionname(collectionName);
            // @todo: Find a more isomorphic way to do this base64 round-trip
            req.setQueryjson(Buffer.from(JSON.stringify(query)).toString('base64'));
            const res = (yield this.unary(api_pb_service_1.API.Find, req));
            const ret = {
                instancesList: res.instancesList.map((instance) => JSON.parse(Buffer.from(instance, 'base64').toString())),
            };
            return ret;
        });
    }
    /**
     * findByID queries the store for the id of an instance.
     * @param dbID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     * @param ID The id of the instance to search for.
     */
    findByID(dbID, collectionName, ID) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = new pb.FindByIDRequest();
            req.setDbid(dbID.toBytes());
            req.setCollectionname(collectionName);
            req.setInstanceid(ID);
            const res = (yield this.unary(api_pb_service_1.API.FindByID, req));
            const ret = {
                instance: JSON.parse(Buffer.from(res.instance, 'base64').toString()),
            };
            return ret;
        });
    }
    /**
     * readTransaction creates a new read-only transaction object. See ReadTransaction for details.
     * @param dbID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     */
    readTransaction(dbID, collectionName) {
        const client = grpc_web_1.grpc.client(api_pb_service_1.API.ReadTransaction, {
            host: this.serviceHost,
            transport: this.rpcOptions.transport,
            debug: this.rpcOptions.debug,
        });
        return new models_1.ReadTransaction(this.context, client, dbID, collectionName);
    }
    /**
     * writeTransaction creates a new writeable transaction object. See WriteTransaction for details.
     * @param dbID the ID of the database
     * @param collectionName The human-readable name of the model to use.
     */
    writeTransaction(dbID, collectionName) {
        const client = grpc_web_1.grpc.client(api_pb_service_1.API.WriteTransaction, {
            host: this.serviceHost,
            transport: this.rpcOptions.transport,
            debug: this.rpcOptions.debug,
        });
        return new models_1.WriteTransaction(this.context, client, dbID, collectionName);
    }
    /**
     * listen opens a long-lived connection with a remote node, running the given callback on each new update to the given instance.
     * The return value is a `close` function, which cleanly closes the connection with the remote node.
     * @param dbID the ID of the database
     * @param filters contains an array of Filters
     * @param callback The callback to call on each update to the given instance.
     */
    listen(dbID, filters, callback) {
        const req = new pb.ListenRequest();
        req.setDbid(dbID.toBytes());
        for (const filter of filters) {
            const requestFilter = new pb.ListenRequest.Filter();
            if (filter.instanceID) {
                requestFilter.setInstanceid(filter.instanceID);
            }
            else if (filter.collectionName) {
                requestFilter.setCollectionname(filter.collectionName);
            }
            if (filter.actionTypes) {
                for (const at of filter.actionTypes) {
                    switch (at) {
                        case 'ALL': {
                            requestFilter.setAction(pb.ListenRequest.Filter.Action.ALL);
                            break;
                        }
                        case 'CREATE': {
                            requestFilter.setAction(pb.ListenRequest.Filter.Action.CREATE);
                            break;
                        }
                        case 'SAVE': {
                            requestFilter.setAction(pb.ListenRequest.Filter.Action.SAVE);
                            break;
                        }
                        case 'DELETE': {
                            requestFilter.setAction(pb.ListenRequest.Filter.Action.DELETE);
                            break;
                        }
                    }
                }
            }
            else {
                requestFilter.setAction(0);
            }
            req.addFilters(requestFilter);
        }
        const metadata = JSON.parse(JSON.stringify(this.context));
        const res = grpc_web_1.grpc.invoke(api_pb_service_1.API.Listen, {
            host: this.serviceHost,
            transport: this.rpcOptions.transport,
            debug: this.rpcOptions.debug,
            request: req,
            metadata,
            onMessage: (rec) => {
                const ret = {
                    instance: JSON.parse(Buffer.from(rec.getInstance_asU8()).toString()),
                };
                next_tick_1.default(() => callback(ret));
            },
            onEnd: (status, message, _trailers) => {
                if (status !== grpc_web_1.grpc.Code.OK) {
                    next_tick_1.default(() => callback(undefined, new Error(message)));
                }
                next_tick_1.default(callback);
            },
        });
        return res.close.bind(res);
    }
    unary(methodDescriptor, req) {
        return __awaiter(this, void 0, void 0, function* () {
            const metadata = JSON.parse(JSON.stringify(this.context));
            return new Promise((resolve, reject) => {
                grpc_web_1.grpc.unary(methodDescriptor, {
                    transport: this.rpcOptions.transport,
                    debug: this.rpcOptions.debug,
                    request: req,
                    host: this.serviceHost,
                    metadata,
                    onEnd: (res) => {
                        const { status, statusMessage, message } = res;
                        if (status === grpc_web_1.grpc.Code.OK) {
                            if (message) {
                                resolve(message.toObject());
                            }
                            else {
                                resolve();
                            }
                        }
                        else {
                            reject(new Error(statusMessage));
                        }
                    },
                });
            });
        });
    }
}
exports.Client = Client;
// eslint-disable-next-line import/no-default-export
exports.default = Client;
//# sourceMappingURL=index.js.map