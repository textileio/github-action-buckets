"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable import/first */
;
global.WebSocket = require('isomorphic-ws');
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const threads_id_1 = require("@textile/threads-id");
const grpc_web_1 = require("@improbable-eng/grpc-web");
const chai_1 = require("chai");
const threads_client_1 = require("@textile/threads-client");
const threads_core_1 = require("@textile/threads-core");
const context_1 = require("@textile/context");
const browser_or_node_1 = require("browser-or-node");
const users_1 = require("./users");
const utils_1 = require("./utils");
const buckets_1 = require("./buckets");
// Settings for localhost development and testing
const addrApiurl = 'http://127.0.0.1:3007';
const addrGatewayUrl = 'http://127.0.0.1:8006';
const wrongError = new Error('wrong error!');
const sessionSecret = 'textilesession';
describe('Users...', () => {
    describe('getThread', () => {
        const ctx = new context_1.Context(addrApiurl, undefined);
        const client = new users_1.Users(ctx);
        let dev;
        before(function () {
            return __awaiter(this, void 0, void 0, function* () {
                this.timeout(3000);
                const { user } = yield utils_1.signUp(ctx, addrGatewayUrl, sessionSecret);
                if (user)
                    dev = user;
            });
        });
        it('should handle bad keys', () => __awaiter(void 0, void 0, void 0, function* () {
            // No key
            try {
                yield client.getThread('foo', ctx);
                throw wrongError;
            }
            catch (err) {
                chai_1.expect(err).to.not.equal(wrongError);
                chai_1.expect(err.code).to.equal(grpc_web_1.grpc.Code.Unauthenticated);
            }
            // No key signature
            const tmp = new context_1.Context(addrApiurl).withSession(dev.session);
            const key = yield utils_1.createKey(tmp, 'ACCOUNT');
            try {
                yield client.getThread('foo', ctx.withAPIKey(key.key));
                throw wrongError;
            }
            catch (err) {
                chai_1.expect(err).to.not.equal(wrongError);
                chai_1.expect(err.code).to.equal(grpc_web_1.grpc.Code.Unauthenticated);
            }
            // Old key signature
            const sig = yield utils_1.createAPISig(key.secret, new Date(Date.now() - 1000 * 60));
            try {
                yield client.getThread('foo', ctx.withAPISig(sig));
                throw wrongError;
            }
            catch (err) {
                chai_1.expect(err).to.not.equal(wrongError);
                chai_1.expect(err.code).to.equal(grpc_web_1.grpc.Code.Unauthenticated);
            }
        }));
        it('should handle account keys', () => __awaiter(void 0, void 0, void 0, function* () {
            const key = yield utils_1.createKey(ctx.withSession(dev.session), 'ACCOUNT');
            yield ctx.withAPIKey(key.key).withUserKey(key);
            // Not found
            try {
                yield client.getThread('foo');
                throw wrongError;
            }
            catch (err) {
                chai_1.expect(err).to.not.equal(wrongError);
                chai_1.expect(err.code).to.equal(grpc_web_1.grpc.Code.NotFound);
            }
            // All good
            const id = threads_id_1.ThreadID.fromRandom();
            const db = new threads_client_1.Client(ctx);
            yield db.newDB(id, ctx.withThreadName('foo'));
            const res = yield client.getThread('foo');
            chai_1.expect(res.name).to.equal('foo');
        }));
        it('should handle users keys', () => __awaiter(void 0, void 0, void 0, function* () {
            // Reset client context (just for the tests)
            const ctx = new context_1.Context(addrApiurl);
            client.context = ctx;
            const tmp = new context_1.Context(addrApiurl).withSession(dev.session);
            const key = yield utils_1.createKey(tmp, 'USER');
            yield ctx.withAPIKey(key.key).withUserKey(key);
            // No token
            try {
                yield client.getThread('foo');
                throw wrongError;
            }
            catch (err) {
                chai_1.expect(err).to.not.equal(wrongError);
                chai_1.expect(err.code).to.equal(grpc_web_1.grpc.Code.Unauthenticated);
            }
            // Not found
            const db = new threads_client_1.Client(ctx);
            const identity = yield threads_core_1.Libp2pCryptoIdentity.fromRandom();
            yield db.getToken(identity);
            try {
                yield client.getThread('foo');
                throw wrongError;
            }
            catch (err) {
                chai_1.expect(err).to.not.equal(wrongError);
                chai_1.expect(err.code).to.equal(grpc_web_1.grpc.Code.NotFound);
            }
            // All good
            const id = threads_id_1.ThreadID.fromRandom();
            yield db.newDB(id, ctx.withThreadName('foo'));
            const res = yield client.getThread('foo');
            chai_1.expect(res.name).to.equal('foo');
        }));
    });
    describe('listThreads', () => {
        const ctx = new context_1.Context(addrApiurl, undefined);
        const client = new users_1.Users(ctx);
        let dev;
        before(function () {
            return __awaiter(this, void 0, void 0, function* () {
                this.timeout(3000);
                const { user } = yield utils_1.signUp(ctx, addrGatewayUrl, sessionSecret);
                if (user)
                    dev = user;
            });
        });
        it('should handle bad keys', () => __awaiter(void 0, void 0, void 0, function* () {
            // No key
            try {
                yield client.listThreads();
                throw wrongError;
            }
            catch (err) {
                chai_1.expect(err).to.not.equal(wrongError);
                chai_1.expect(err.code).to.equal(grpc_web_1.grpc.Code.Unauthenticated);
            }
            // No key signature
            const tmp = new context_1.Context(addrApiurl).withSession(dev.session);
            const key = yield utils_1.createKey(tmp, 'ACCOUNT');
            try {
                yield client.listThreads(ctx.withAPIKey(key.key));
                throw wrongError;
            }
            catch (err) {
                chai_1.expect(err).to.not.equal(wrongError);
                chai_1.expect(err.code).to.equal(grpc_web_1.grpc.Code.Unauthenticated);
            }
            // Old key signature
            const sig = yield utils_1.createAPISig(key.secret, new Date(Date.now() - 1000 * 60));
            try {
                yield client.listThreads(ctx.withAPISig(sig));
                throw wrongError;
            }
            catch (err) {
                chai_1.expect(err).to.not.equal(wrongError);
                chai_1.expect(err.code).to.equal(grpc_web_1.grpc.Code.Unauthenticated);
            }
        }));
        it('should handle account keys', () => __awaiter(void 0, void 0, void 0, function* () {
            const key = yield utils_1.createKey(ctx.withSession(dev.session), 'ACCOUNT');
            yield ctx.withAPIKey(key.key).withUserKey(key);
            // Empty
            let res = yield client.listThreads();
            chai_1.expect(res.listList).to.have.length(0);
            // Got one
            const id = threads_id_1.ThreadID.fromRandom();
            const db = new threads_client_1.Client(ctx);
            yield db.newDB(id);
            res = yield client.listThreads();
            chai_1.expect(res.listList).to.have.length(1);
        }));
        it('should handle users keys', () => __awaiter(void 0, void 0, void 0, function* () {
            // Reset client context (just for the tests)
            const ctx = new context_1.Context(addrApiurl);
            client.context = ctx;
            const tmp = new context_1.Context(addrApiurl).withSession(dev.session);
            const key = yield utils_1.createKey(tmp, 'USER');
            yield ctx.withAPIKey(key.key).withUserKey(key);
            // No token
            try {
                yield client.listThreads();
                throw wrongError;
            }
            catch (err) {
                chai_1.expect(err).to.not.equal(wrongError);
                chai_1.expect(err.code).to.equal(grpc_web_1.grpc.Code.Unauthenticated);
            }
            // Empty
            const db = new threads_client_1.Client(ctx);
            const identity = yield threads_core_1.Libp2pCryptoIdentity.fromRandom();
            yield db.getToken(identity);
            let res = yield client.listThreads();
            chai_1.expect(res.listList).to.have.length(0);
            // Got one
            const id = threads_id_1.ThreadID.fromRandom();
            yield db.newDB(id, ctx.withThreadName('foo'));
            res = yield client.listThreads();
            chai_1.expect(res.listList).to.have.length(1);
            chai_1.expect(res.listList[0].name).to.equal('foo');
        }));
    });
    describe('Buckets and accounts', () => {
        context('a developer', () => {
            const ctx = new context_1.Context(addrApiurl, undefined);
            let dev;
            it('should sign-up, create an API key, and sign it for the requests', () => __awaiter(void 0, void 0, void 0, function* () {
                // @note This should be done using the cli
                const { user } = yield utils_1.signUp(ctx, addrGatewayUrl, sessionSecret);
                if (user)
                    dev = user;
                // @note This should be done using the cli
                ctx.withSession(dev.session);
                const key = yield utils_1.createKey(ctx, 'ACCOUNT');
                yield ctx.withAPIKey(key.key).withUserKey(key);
                chai_1.expect(ctx.toJSON()).to.have.ownProperty('x-textile-api-sig');
            })).timeout(3000);
            it('should then create a db for the bucket', () => __awaiter(void 0, void 0, void 0, function* () {
                const db = new threads_client_1.Client(ctx);
                const id = threads_id_1.ThreadID.fromRandom();
                yield db.newDB(id, ctx.withThreadName('my-buckets'));
                chai_1.expect(ctx.toJSON()).to.have.ownProperty('x-textile-thread-name');
            }));
            it('should then initialize a new bucket in the db and push to it', function () {
                var _a, _b;
                return __awaiter(this, void 0, void 0, function* () {
                    if (browser_or_node_1.isBrowser)
                        return this.skip();
                    // Initialize a new bucket in the db
                    const buckets = new buckets_1.Buckets(ctx);
                    const buck = yield buckets.init('mybuck');
                    chai_1.expect((_a = buck.root) === null || _a === void 0 ? void 0 : _a.name).to.equal('mybuck');
                    // Finally, push a file to the bucket.
                    const pth = path_1.default.join(__dirname, '..', 'testdata');
                    const stream = fs_1.default.createReadStream(path_1.default.join(pth, 'file1.jpg'));
                    const rootKey = ((_b = buck.root) === null || _b === void 0 ? void 0 : _b.key) || '';
                    const { root } = yield buckets.pushPath(rootKey, 'dir1/file1.jpg', stream);
                    chai_1.expect(root).to.not.be.undefined;
                    // We should have a thread named "my-buckets"
                    const users = new users_1.Users(ctx);
                    const res = yield users.getThread('my-buckets');
                    chai_1.expect(res.id).to.deep.equal(ctx.toJSON()['x-textile-thread']);
                });
            });
        });
        context('a developer with a user', () => {
            const ctx = new context_1.Context(addrApiurl, undefined);
            let dev;
            const userContext = new context_1.Context(addrApiurl);
            it('should sign-up, create an API key, and sign it for the requests', () => __awaiter(void 0, void 0, void 0, function* () {
                // @note This should be done using the cli
                const { user } = yield utils_1.signUp(ctx, addrGatewayUrl, sessionSecret);
                if (user)
                    dev = user;
                ctx.withSession(dev.session);
                // @note This should be done using the cli
                // This time they create a user key
                const key = yield utils_1.createKey(ctx, 'USER');
                // Update user context
                yield userContext.withAPIKey(key.key).withUserKey(key);
                chai_1.expect(userContext.toJSON()).to.have.ownProperty('x-textile-api-sig');
            })).timeout(3000);
            it('should then generate a user identity and get a token for it', () => __awaiter(void 0, void 0, void 0, function* () {
                const identity = yield threads_core_1.Libp2pCryptoIdentity.fromRandom();
                const db = new threads_client_1.Client(userContext);
                yield db.getToken(identity);
            }));
            it('should then create a db for the bucket', () => __awaiter(void 0, void 0, void 0, function* () {
                const id = threads_id_1.ThreadID.fromRandom();
                // Just for the test, recrete the client here
                const db = new threads_client_1.Client(userContext);
                yield db.newDB(id, userContext.withThreadName('my-buckets'));
                chai_1.expect(userContext.toJSON()).to.have.ownProperty('x-textile-thread-name');
            }));
            it('should then initialize a new bucket in the db and push to it', function () {
                var _a, _b;
                return __awaiter(this, void 0, void 0, function* () {
                    if (browser_or_node_1.isBrowser)
                        return this.skip();
                    // Initialize a new bucket in the db
                    const buckets = new buckets_1.Buckets(userContext);
                    const buck = yield buckets.init('mybuck');
                    chai_1.expect((_a = buck.root) === null || _a === void 0 ? void 0 : _a.name).to.equal('mybuck');
                    // Finally, push a file to the bucket.
                    const pth = path_1.default.join(__dirname, '..', 'testdata');
                    const stream = fs_1.default.createReadStream(path_1.default.join(pth, 'file1.jpg'));
                    const rootKey = ((_b = buck.root) === null || _b === void 0 ? void 0 : _b.key) || '';
                    const { root } = yield buckets.pushPath(rootKey, 'dir1/file1.jpg', stream);
                    chai_1.expect(root).to.not.be.undefined;
                    // We should have a thread named "my-buckets"
                    const users = new users_1.Users(userContext);
                    const res = yield users.getThread('my-buckets');
                    chai_1.expect(res.id).to.deep.equal(userContext.toJSON()['x-textile-thread']);
                });
            });
        });
    });
});
//# sourceMappingURL=users.spec.js.map