"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Deferred_1 = __importDefault(require("../Deferred"));
const LinkedQueue_1 = __importDefault(require("../LinkedQueue"));
const common_1 = require("../common");
const fromDom_1 = __importDefault(require("../fromDom"));
const fromEmitter_1 = __importDefault(require("../fromEmitter"));
/**
 * Balances a push queue with a pull queue.
 */
class Channel {
    constructor(pushLimit = 0, pullLimit = 0) {
        /** Determines whether new values can be pushed or pulled */
        this.closed = false;
        this.pushBuffer = new LinkedQueue_1.default(pushLimit);
        this.pullBuffer = new LinkedQueue_1.default(pullLimit);
    }
    /**
     * Pull a promise of the next [[Result]].
     */
    next() {
        if (this.closed) {
            return Promise.resolve(common_1.doneResult);
        }
        if (this.pushBuffer.length === 0) {
            const defer = new Deferred_1.default();
            // Buffer the pull to be resolved later
            this.pullBuffer.enqueue(defer);
            // Return the buffered promise that will be resolved and dequeued when a value is pushed
            return defer.promise;
        }
        const { result, defer } = this.pushBuffer.dequeue();
        defer.resolve(result);
        if (result.done) {
            this.close();
        }
        return defer.promise;
    }
    /**
     * Push the next [[Result]] value.
     *
     * @param value
     * @param done If true, closes the balancer when this result is resolved
     * @throws Throws if the balancer is already closed
     */
    push(value, done = false) {
        if (this.closed) {
            return Promise.resolve(common_1.doneResult);
        }
        const result = {
            value,
            done,
        };
        if (this.pullBuffer.length > 0) {
            return this.pullBuffer.dequeue().resolve(result);
        }
        const defer = new Deferred_1.default();
        this.pushBuffer.enqueue({ result, defer });
        return defer.promise;
    }
    /**
     * Returns itself, since [[Balancer]] already implements the iterator protocol.
     */
    [Symbol.asyncIterator]() {
        return this;
    }
    /**
     * Closes the balancer; clears the queues and makes [[Balancer.next]] only
     * return [[closedResult]].
     *
     * @param value The result value to be returned
     */
    async return(value) {
        this.close();
        return {
            done: true,
            value: value,
        };
    }
    close() {
        if (this.closed) {
            return;
        }
        this.closed = true;
        // Clear the queues
        this.pushBuffer.forEach(({ defer: { resolve } }) => void resolve(common_1.doneResult));
        this.pushBuffer.clear();
        this.pullBuffer.forEach(({ resolve }) => void resolve(common_1.doneResult));
        this.pullBuffer.clear();
    }
    /**
     * Convert [[Balancer]] to a generic async iterable iterator to hide implementation details.
     *
     * @param onReturn Optional callback for when the iterator is closed with [[Balancer.return]]
     * @throws Throws if called when closed
     */
    wrap(onReturn) {
        if (this.closed) {
            throw Error('Balancer is closed');
        }
        return {
            [Symbol.asyncIterator]() {
                return this;
            },
            next: () => this.next(),
            return: async (value) => {
                if (onReturn) {
                    onReturn();
                }
                return this.return(value);
            },
        };
    }
}
exports.default = Channel;
Channel.fromDom = fromDom_1.default(() => new Channel());
Channel.fromEmitter = fromEmitter_1.default(() => new Channel());
//# sourceMappingURL=Channel.js.map