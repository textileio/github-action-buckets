/// <reference types="node" />
import Deferred from '../Deferred';
import LinkedQueue from '../LinkedQueue';
import { PushAdapter } from '../common';
declare type Result<A> = IteratorResult<A>;
/**
 * Async iterable iterator with a non-optional [[return]] method.
 */
interface WrappedBalancer<A> extends AsyncIterableIterator<A> {
    return(value?: A): Promise<Result<A>>;
    throw?: undefined;
}
interface Unpushed<A> {
    result: Result<A>;
    defer: Deferred<Result<A>>;
}
/**
 * Balances a push queue with a pull queue.
 */
export default class Channel<A> implements PushAdapter<A> {
    /** Pushed results waiting for pulls to resolve */
    readonly pushBuffer: LinkedQueue<Unpushed<A>>;
    /** Unresolved pulls waiting for results to be pushed */
    readonly pullBuffer: LinkedQueue<Deferred<Result<A>>>;
    /** Determines whether new values can be pushed or pulled */
    private closed;
    static fromDom: (type: "waiting" | "error" | "abort" | "cancel" | "progress" | "ended" | "change" | "input" | "select" | "animationcancel" | "animationend" | "animationiteration" | "animationstart" | "auxclick" | "blur" | "canplay" | "canplaythrough" | "click" | "close" | "contextmenu" | "cuechange" | "dblclick" | "drag" | "dragend" | "dragenter" | "dragexit" | "dragleave" | "dragover" | "dragstart" | "drop" | "durationchange" | "emptied" | "focus" | "focusin" | "focusout" | "gotpointercapture" | "invalid" | "keydown" | "keypress" | "keyup" | "load" | "loadeddata" | "loadedmetadata" | "loadstart" | "lostpointercapture" | "mousedown" | "mouseenter" | "mouseleave" | "mousemove" | "mouseout" | "mouseover" | "mouseup" | "pause" | "play" | "playing" | "pointercancel" | "pointerdown" | "pointerenter" | "pointerleave" | "pointermove" | "pointerout" | "pointerover" | "pointerup" | "ratechange" | "reset" | "resize" | "scroll" | "securitypolicyviolation" | "seeked" | "seeking" | "selectionchange" | "selectstart" | "stalled" | "submit" | "suspend" | "timeupdate" | "toggle" | "touchcancel" | "touchend" | "touchmove" | "touchstart" | "transitioncancel" | "transitionend" | "transitionrun" | "transitionstart" | "volumechange" | "wheel", target: EventTarget & {
        addEventListener(type: "waiting" | "error" | "abort" | "cancel" | "progress" | "ended" | "change" | "input" | "select" | "animationcancel" | "animationend" | "animationiteration" | "animationstart" | "auxclick" | "blur" | "canplay" | "canplaythrough" | "click" | "close" | "contextmenu" | "cuechange" | "dblclick" | "drag" | "dragend" | "dragenter" | "dragexit" | "dragleave" | "dragover" | "dragstart" | "drop" | "durationchange" | "emptied" | "focus" | "focusin" | "focusout" | "gotpointercapture" | "invalid" | "keydown" | "keypress" | "keyup" | "load" | "loadeddata" | "loadedmetadata" | "loadstart" | "lostpointercapture" | "mousedown" | "mouseenter" | "mouseleave" | "mousemove" | "mouseout" | "mouseover" | "mouseup" | "pause" | "play" | "playing" | "pointercancel" | "pointerdown" | "pointerenter" | "pointerleave" | "pointermove" | "pointerout" | "pointerover" | "pointerup" | "ratechange" | "reset" | "resize" | "scroll" | "securitypolicyviolation" | "seeked" | "seeking" | "selectionchange" | "selectstart" | "stalled" | "submit" | "suspend" | "timeupdate" | "toggle" | "touchcancel" | "touchend" | "touchmove" | "touchstart" | "transitioncancel" | "transitionend" | "transitionrun" | "transitionstart" | "volumechange" | "wheel", listener: (e: Event | ErrorEvent | AnimationEvent | UIEvent | DragEvent | MouseEvent | FocusEvent | KeyboardEvent | PointerEvent | ProgressEvent<EventTarget> | SecurityPolicyViolationEvent | TouchEvent | TransitionEvent | WheelEvent) => void, options?: boolean | AddEventListenerOptions | undefined): void;
        removeEventListener(type: "waiting" | "error" | "abort" | "cancel" | "progress" | "ended" | "change" | "input" | "select" | "animationcancel" | "animationend" | "animationiteration" | "animationstart" | "auxclick" | "blur" | "canplay" | "canplaythrough" | "click" | "close" | "contextmenu" | "cuechange" | "dblclick" | "drag" | "dragend" | "dragenter" | "dragexit" | "dragleave" | "dragover" | "dragstart" | "drop" | "durationchange" | "emptied" | "focus" | "focusin" | "focusout" | "gotpointercapture" | "invalid" | "keydown" | "keypress" | "keyup" | "load" | "loadeddata" | "loadedmetadata" | "loadstart" | "lostpointercapture" | "mousedown" | "mouseenter" | "mouseleave" | "mousemove" | "mouseout" | "mouseover" | "mouseup" | "pause" | "play" | "playing" | "pointercancel" | "pointerdown" | "pointerenter" | "pointerleave" | "pointermove" | "pointerout" | "pointerover" | "pointerup" | "ratechange" | "reset" | "resize" | "scroll" | "securitypolicyviolation" | "seeked" | "seeking" | "selectionchange" | "selectstart" | "stalled" | "submit" | "suspend" | "timeupdate" | "toggle" | "touchcancel" | "touchend" | "touchmove" | "touchstart" | "transitioncancel" | "transitionend" | "transitionrun" | "transitionstart" | "volumechange" | "wheel", listener: (e: Event | ErrorEvent | AnimationEvent | UIEvent | DragEvent | MouseEvent | FocusEvent | KeyboardEvent | PointerEvent | ProgressEvent<EventTarget> | SecurityPolicyViolationEvent | TouchEvent | TransitionEvent | WheelEvent) => void, options?: boolean | AddEventListenerOptions | undefined): void;
    }, options?: boolean | AddEventListenerOptions | undefined) => AsyncIterableIterator<Event | ErrorEvent | AnimationEvent | UIEvent | DragEvent | MouseEvent | FocusEvent | KeyboardEvent | PointerEvent | ProgressEvent<EventTarget> | SecurityPolicyViolationEvent | TouchEvent | TransitionEvent | WheelEvent>;
    static fromEmitter: (type: string | symbol, emitter: NodeJS.EventEmitter) => AsyncIterableIterator<any>;
    constructor(pushLimit?: number, pullLimit?: number);
    /**
     * Pull a promise of the next [[Result]].
     */
    next(): Promise<Result<A>>;
    /**
     * Push the next [[Result]] value.
     *
     * @param value
     * @param done If true, closes the balancer when this result is resolved
     * @throws Throws if the balancer is already closed
     */
    push(value: A, done?: boolean): Promise<Result<A>>;
    /**
     * Returns itself, since [[Balancer]] already implements the iterator protocol.
     */
    [Symbol.asyncIterator](): this;
    /**
     * Closes the balancer; clears the queues and makes [[Balancer.next]] only
     * return [[closedResult]].
     *
     * @param value The result value to be returned
     */
    return(value?: A): Promise<Result<A>>;
    close(): void;
    /**
     * Convert [[Balancer]] to a generic async iterable iterator to hide implementation details.
     *
     * @param onReturn Optional callback for when the iterator is closed with [[Balancer.return]]
     * @throws Throws if called when closed
     */
    wrap(onReturn?: () => void): WrappedBalancer<A>;
}
export {};
