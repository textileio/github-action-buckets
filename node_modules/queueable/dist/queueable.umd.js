(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.Queueable = {}));
}(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    /**
     * Exposes the promise executor callbacks (resolve, reject).
     */
    class Deferred {
        constructor() {
            this.promise = new Promise((resolve, reject) => {
                this.resolve = value => {
                    resolve(value);
                    return this.promise;
                };
                this.reject = reason => {
                    reject(reason);
                    return this.promise;
                };
            });
        }
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var fastList = createCommonjsModule(function (module, exports) {
    (function() { // closure for web browsers

    function Item (data, prev, next) {
      this.next = next;
      if (next) next.prev = this;
      this.prev = prev;
      if (prev) prev.next = this;
      this.data = data;
    }

    function FastList () {
      if (!(this instanceof FastList)) return new FastList
      this._head = null;
      this._tail = null;
      this.length = 0;
    }

    FastList.prototype =
    { push: function (data) {
        this._tail = new Item(data, this._tail, null);
        if (!this._head) this._head = this._tail;
        this.length ++;
      }

    , pop: function () {
        if (this.length === 0) return undefined
        var t = this._tail;
        this._tail = t.prev;
        if (t.prev) {
          t.prev = this._tail.next = null;
        }
        this.length --;
        if (this.length === 1) this._head = this._tail;
        else if (this.length === 0) this._head = this._tail = null;
        return t.data
      }

    , unshift: function (data) {
        this._head = new Item(data, null, this._head);
        if (!this._tail) this._tail = this._head;
        this.length ++;
      }

    , shift: function () {
        if (this.length === 0) return undefined
        var h = this._head;
        this._head = h.next;
        if (h.next) {
          h.next = this._head.prev = null;
        }
        this.length --;
        if (this.length === 1) this._tail = this._head;
        else if (this.length === 0) this._head = this._tail = null;
        return h.data
      }

    , item: function (n) {
        if (n < 0) n = this.length + n;
        var h = this._head;
        while (n-- > 0 && h) h = h.next;
        return h ? h.data : undefined
      }

    , slice: function (n, m) {
        if (!n) n = 0;
        if (!m) m = this.length;
        if (m < 0) m = this.length + m;
        if (n < 0) n = this.length + n;

        if (m === n) {
          return []
        }

        if (m < n) {
          throw new Error("invalid offset: "+n+","+m+" (length="+this.length+")")
        }

        var len = m - n
          , ret = new Array(len)
          , i = 0
          , h = this._head;
        while (n-- > 0 && h) h = h.next;
        while (i < len && h) {
          ret[i++] = h.data;
          h = h.next;
        }
        return ret
      }

    , drop: function () {
        FastList.call(this);
      }

    , forEach: function (fn, thisp) {
        var p = this._head
          , i = 0
          , len = this.length;
        while (i < len && p) {
          fn.call(thisp || this, p.data, i, this);
          p = p.next;
          i ++;
        }
      }

    , map: function (fn, thisp) {
        var n = new FastList();
        this.forEach(function (v, i, me) {
          n.push(fn.call(thisp || me, v, i, me));
        });
        return n
      }

    , filter: function (fn, thisp) {
        var n = new FastList();
        this.forEach(function (v, i, me) {
          if (fn.call(thisp || me, v, i, me)) n.push(v);
        });
        return n
      }

    , reduce: function (fn, val, thisp) {
        var i = 0
          , p = this._head
          , len = this.length;
        if (!val) {
          i = 1;
          val = p && p.data;
          p = p && p.next;
        }
        while (i < len && p) {
          val = fn.call(thisp || this, val, p.data, this);
          i ++;
          p = p.next;
        }
        return val
      }
    };

    module.exports = FastList;

    })();
    });

    /**
     * First-in, first-out (FIFO) buffer (queue) with default item values.
     * Optionally circular based on [[Queue.limit]].
     */
    class Queue {
        constructor(
        /** The length after which the queue becomes circular, i.e., discards oldest items. */
        limit = 0) {
            this.limit = limit;
            this.length = 0;
            this.list = new fastList();
        }
        /**
         * Add an item to the end of the queue.
         */
        enqueue(value) {
            const { list } = this;
            if (this.limit > 0 && list.length === this.limit) {
                // Discard oldest item
                list.shift();
            }
            this.length += 1;
            list.push(value);
        }
        /**
         * Return the oldest item from the queue.
         */
        dequeue() {
            if (this.length === 0) {
                throw Error('Queue is empty');
            }
            this.length -= 1;
            return this.list.shift();
        }
        clear() {
            this.length = 0;
            this.list.drop();
        }
        forEach(f) {
            this.list.forEach(f);
        }
    }

    /** The result returned from closed iterators. */
    const doneResult = Object.freeze({
        value: undefined,
        done: true,
    });

    // TODO add overloads for special event targets (Window, Document)
    /**
     * Convert DOM events to an async iterable iterator.
     */
    const fromDom = (init) => (type, target, options) => {
        const adapter = init();
        const listener = (event) => void adapter.push(event);
        target.addEventListener(type, listener, options);
        return adapter.wrap(() => target.removeEventListener(type, listener, options));
    };

    // TODO implement strict-event-emitter-types support
    /**
     * Convert node EventEmitter events to an async iterable iterator.
     */
    const fromEmitter = (init) => (type, emitter) => {
        const adapter = init();
        const listener = (event) => void adapter.push(event);
        emitter.addListener(type, listener);
        return adapter.wrap(() => void emitter.removeListener(type, listener));
    };

    /**
     * Balances a push queue with a pull queue.
     */
    class Channel {
        constructor(pushLimit = 0, pullLimit = 0) {
            /** Determines whether new values can be pushed or pulled */
            this.closed = false;
            this.pushBuffer = new Queue(pushLimit);
            this.pullBuffer = new Queue(pullLimit);
        }
        /**
         * Pull a promise of the next [[Result]].
         */
        next() {
            if (this.closed) {
                return Promise.resolve(doneResult);
            }
            if (this.pushBuffer.length === 0) {
                const defer = new Deferred();
                // Buffer the pull to be resolved later
                this.pullBuffer.enqueue(defer);
                // Return the buffered promise that will be resolved and dequeued when a value is pushed
                return defer.promise;
            }
            const { result, defer } = this.pushBuffer.dequeue();
            defer.resolve(result);
            if (result.done) {
                this.close();
            }
            return defer.promise;
        }
        /**
         * Push the next [[Result]] value.
         *
         * @param value
         * @param done If true, closes the balancer when this result is resolved
         * @throws Throws if the balancer is already closed
         */
        push(value, done = false) {
            if (this.closed) {
                return Promise.resolve(doneResult);
            }
            const result = {
                value,
                done,
            };
            if (this.pullBuffer.length > 0) {
                return this.pullBuffer.dequeue().resolve(result);
            }
            const defer = new Deferred();
            this.pushBuffer.enqueue({ result, defer });
            return defer.promise;
        }
        /**
         * Returns itself, since [[Balancer]] already implements the iterator protocol.
         */
        [Symbol.asyncIterator]() {
            return this;
        }
        /**
         * Closes the balancer; clears the queues and makes [[Balancer.next]] only
         * return [[closedResult]].
         *
         * @param value The result value to be returned
         */
        return(value) {
            return __awaiter(this, void 0, void 0, function* () {
                this.close();
                return {
                    done: true,
                    value: value,
                };
            });
        }
        close() {
            if (this.closed) {
                return;
            }
            this.closed = true;
            // Clear the queues
            this.pushBuffer.forEach(({ defer: { resolve } }) => void resolve(doneResult));
            this.pushBuffer.clear();
            this.pullBuffer.forEach(({ resolve }) => void resolve(doneResult));
            this.pullBuffer.clear();
        }
        /**
         * Convert [[Balancer]] to a generic async iterable iterator to hide implementation details.
         *
         * @param onReturn Optional callback for when the iterator is closed with [[Balancer.return]]
         * @throws Throws if called when closed
         */
        wrap(onReturn) {
            if (this.closed) {
                throw Error('Balancer is closed');
            }
            return {
                [Symbol.asyncIterator]() {
                    return this;
                },
                next: () => this.next(),
                return: (value) => __awaiter(this, void 0, void 0, function* () {
                    if (onReturn) {
                        onReturn();
                    }
                    return this.return(value);
                }),
            };
        }
    }
    Channel.fromDom = fromDom(() => new Channel());
    Channel.fromEmitter = fromEmitter(() => new Channel());

    /**
     * Multicasts pushed values to a variable number of async iterable iterators
     * as receivers or subscribers.
     *
     * Does not buffer pushed values; if no receivers are registered, pushed
     * values are silently discarded.
     */
    class Multicast {
        constructor(init = () => new Channel()) {
            this.init = init;
            this.receivers = new Set();
        }
        /**
         * Pushes a value to all registered receivers.
         */
        push(value) {
            this.receivers.forEach(balancer => balancer.push(value));
            return this;
        }
        /**
         * Creates and registers a receiver.
         */
        [Symbol.asyncIterator]() {
            const producer = this.init();
            const { receivers } = this;
            receivers.add(producer);
            if (this.onStart && receivers.size === 1) {
                this.onStart();
            }
            return producer.wrap(() => {
                receivers.delete(producer);
                if (this.onStop && receivers.size === 0) {
                    this.onStop();
                }
            });
        }
    }

    class LastResult {
        constructor() {
            this.buffer = new Deferred();
            this.closed = false;
            this.resolved = false;
            this.requested = false;
        }
        push(value, done = false) {
            if (this.closed) {
                throw Error('Iterator closed');
            }
            const result = {
                value,
                done,
            };
            if (this.resolved === false) {
                this.resolved = true;
            }
            else {
                this.buffer = new Deferred();
                this.resolved = false;
            }
            this.requested = false;
            this.buffer.resolve(result);
            return this.buffer.promise;
        }
        next() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.closed) {
                    return doneResult;
                }
                this.requested = true;
                return this.buffer.promise;
            });
        }
        return(value) {
            return __awaiter(this, void 0, void 0, function* () {
                this.closed = true;
                if (!this.resolved && this.requested) {
                    this.buffer.resolve(doneResult);
                }
                return Promise.resolve({
                    value: value,
                    done: true,
                });
            });
        }
        wrap(onReturn) {
            const wrapped = {
                next: () => this.next(),
                [Symbol.asyncIterator]() {
                    return this;
                },
                return: (value) => {
                    if (onReturn) {
                        onReturn();
                    }
                    return this.return(value);
                },
            };
            return wrapped;
        }
        [Symbol.asyncIterator]() {
            return this;
        }
    }
    LastResult.fromDom = fromDom(() => new LastResult());
    LastResult.fromEmitter = fromEmitter(() => new LastResult());

    exports.Channel = Channel;
    exports.Deferred = Deferred;
    exports.LastResult = LastResult;
    exports.Multicast = Multicast;
    exports.fromDom = fromDom;
    exports.fromEmitter = fromEmitter;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=queueable.umd.js.map
